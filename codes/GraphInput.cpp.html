<html>
							<head>
							  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 

							  <!-- link rel="stylesheet" href="http://acm.math.spbu.ru/~sk1/colorer1/xcode.css">
							  <script src="http://acm.math.spbu.ru/~sk1/colorer1/highlight.pack.js"></script>
							  <script>hljs.initHighlightingOnLoad();</script -->

							  <link rel="stylesheet" title="Default" href="http://acm.math.spbu.ru/~sk1/colorer/my.css">
							  <script src="http://acm.math.spbu.ru/~sk1/colorer/highlight.js"></script>
							  <script src="http://acm.math.spbu.ru/~sk1/colorer/cpp.js"></script>
							  <script>hljs.initHighlightingOnLoad();</script>
							</head>

							<body>

							<pre><code>
#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    // Я обычно делаю так:

    /* Если граф задается списком типа a b, a и b - вершины ребра
     
      Пример:
      4 5    # 4 вершины, 5 ребер
             # Дальше идет описание 5 ребер
      1 2    # Есть ребро между вершиной 1 и 2 и тд
      2 3
      1 3
      3 4
      2 4
     */

    int n, m; // n - количество вершин, m - количество ребер
    cin &gt;&gt; n &gt;&gt; m;

    vector&lt;vector&lt;int&gt; &gt; g(n);
    for (int i = 0; i &lt; m; i++) {
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;

        --a, --b;
        g[a].push_back(b); // Для вершины a добавляю ребро в b
        g[b].push_back(a); // Для вершины b добавляю ребро в a
    }


    /* Если граф задается списком смежности
     
      Пример:
      4  # количество вершин
      0 0 1 1  # если a[i][j] == 1, то между вершинами i и j есть ребро, иначе нет
      1 0 1 0
      1 1 0 1
      0 1 0 0
     */
    
    // Храним табилей
    cin &gt;&gt; n;
    int a[n][n];
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            cin &gt;&gt; a[i][j];
        }
    }

    // Либо храним как в первом случае
    cin &gt;&gt; n;
    vector&lt;vector&lt;int&gt; &gt; c(n);
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            int x;
            cin &gt;&gt; x;

            if (x == 1) {
                c[i].push_back(j); // У вершины i есть ребро в j
            }
        }
    }

    // Я почти всегда делаю через вектора
    // Потому что меньше памяти жрет
}
</code></pre>

							</body>
							</html>

							<font style="visibility:hidden">
